/* tslint:disable:array-type */
/* tslint:disable:no-namespace */
/* tslint:disable:no-string-literal */
/* tslint:disable:max-classes-per-file */
/* tslint:disable:no-trailing-whitespace */

// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================

/**
 * Account Management API
 * API for managing accounts, users, creating API keys, uploading trusted certificates
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import superagent = require("superagent");
import { ApiBase } from "../common/apiBase";
import { SDKError } from "../common/sdkError";

/**
 * This object represents an account creation request.
 */
export interface AccountCreationReq {
    /**
     * Postal address line 1, not longer than 100 characters. Required for commercial accounts only.
     */
    "address_line1"?: string;
    /**
     * Postal address line 2, not longer than 100 characters.
     */
    "address_line2"?: string;
    /**
     * The email address of the account admin, not longer than 254 characters.
     */
    "admin_email"?: string;
    /**
     * The full name of the admin user to be created.
     */
    "admin_full_name"?: string;
    /**
     * The username of the admin user to be created, containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "admin_name"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "admin_password"?: string;
    /**
     * An array of aliases, not more than 10. An alias is not shorter than 8 and not longer than 100 characters.
     */
    "aliases"?: Array<string>;
    /**
     * The city part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "city"?: string;
    /**
     * The name of the company, not longer than 100 characters. Required for commercial accounts only.
     */
    "company"?: string;
    /**
     * The name of the contact person for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "contact"?: string;
    /**
     * Contract number of the customer.
     */
    "contract_number"?: string;
    /**
     * The country part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "country"?: string;
    /**
     * Customer number of the customer.
     */
    "customer_number"?: string;
    /**
     * The display name for the account, not longer than 100 characters.
     */
    "display_name"?: string;
    /**
     * The company email address for this account, not longer than 254 characters. Required for commercial accounts only.
     */
    "email"?: string;
    /**
     * The end market of the account to be created.
     */
    "end_market": string;
    /**
     * The phone number of a representative of the company, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The postal code part of the postal address, not longer than 100 characters.
     */
    "postal_code"?: string;
    /**
     * The state part of the postal address, not longer than 100 characters.
     */
    "state"?: string;
}

/**
 * This object represents an account creation response.
 */
export interface AccountCreationResp {
    /**
     * Postal address line 1, not longer than 100 characters. Required for commercial accounts only.
     */
    "address_line1"?: string;
    /**
     * Postal address line 2, not longer than 100 characters.
     */
    "address_line2"?: string;
    /**
     * The email address of the account admin, not longer than 254 characters.
     */
    "admin_email"?: string;
    /**
     * The full name of the admin user to be created.
     */
    "admin_full_name"?: string;
    /**
     * The ID of the admin user created.
     */
    "admin_id": string;
    /**
     * The admin API key created for the account.
     */
    "admin_key"?: string;
    /**
     * The username of the admin user to be created, containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "admin_name"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "admin_password"?: string;
    /**
     * An array of aliases, not more than 10. An alias is not shorter than 8 and not longer than 100 characters.
     */
    "aliases"?: Array<string>;
    /**
     * The city part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "city"?: string;
    /**
     * The name of the company, not longer than 100 characters. Required for commercial accounts only.
     */
    "company"?: string;
    /**
     * The name of the contact person for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "contact"?: string;
    /**
     * Contract number of the customer.
     */
    "contract_number"?: string;
    /**
     * The country part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "country"?: string;
    /**
     * Customer number of the customer.
     */
    "customer_number"?: string;
    /**
     * The display name for the account, not longer than 100 characters.
     */
    "display_name"?: string;
    /**
     * The company email address for this account, not longer than 254 characters. Required for commercial accounts only.
     */
    "email"?: string;
    /**
     * The end market of the account to be created.
     */
    "end_market": string;
    /**
     * Account ID.
     */
    "id": string;
    /**
     * The phone number of a representative of the company, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The postal code part of the postal address, not longer than 100 characters.
     */
    "postal_code"?: string;
    /**
     * The state part of the postal address, not longer than 100 characters.
     */
    "state"?: string;
}

/**
 * This object represents an account in requests and responses.
 */
export namespace AccountInfo {
    export type MfaStatusEnum = "enforced" | "optional";
    export type ObjectEnum = "account";
    export type StatusEnum = "ENROLLING" | "ACTIVE" | "RESTRICTED" | "SUSPENDED";
}
export interface AccountInfo {
    /**
     * Postal address line 1.
     */
    "address_line1"?: string;
    /**
     * Postal address line 2.
     */
    "address_line2"?: string;
    /**
     * An array of aliases.
     */
    "aliases": Array<string>;
    /**
     * The city part of the postal address.
     */
    "city"?: string;
    /**
     * The name of the company.
     */
    "company"?: string;
    /**
     * The name of the contact person for this account.
     */
    "contact"?: string;
    /**
     * Contract number of the customer.
     */
    "contract_number"?: string;
    /**
     * The country part of the postal address.
     */
    "country"?: string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Account's custom properties as key-value pairs.
     */
    "custom_fields"?: { [key: string]: string; };
    /**
     * Customer number of the customer.
     */
    "customer_number"?: string;
    /**
     * The display name for the account.
     */
    "display_name"?: string;
    /**
     * The company email address for this account.
     */
    "email"?: string;
    /**
     * Account end market.
     */
    "end_market": string;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Indicates how many days (1-180) before account expiration a notification email should be sent.
     */
    "expiration_warning_threshold"?: string;
    /**
     * Account ID.
     */
    "id": string;
    /**
     * The reference token expiration time in minutes for this account.
     */
    "idle_timeout"?: string;
    /**
     * List of limits as key-value pairs if requested.
     */
    "limits"?: { [key: string]: string; };
    /**
     * The enforcement status of the multi-factor authentication, either 'enforced' or 'optional'.
     */
    "mfa_status"?: AccountInfo.MfaStatusEnum;
    /**
     * A list of notification email addresses.
     */
    "notification_emails"?: Array<string>;
    /**
     * Entity name: always 'account'
     */
    "object": AccountInfo.ObjectEnum;
    /**
     * The ID of the parent account, if it has any.
     */
    "parent_id"?: string;
    /**
     * The password policy for this account.
     */
    "password_policy"?: PasswordPolicy;
    /**
     * The phone number of a representative of the company.
     */
    "phone_number"?: string;
    /**
     * List of policies if requested.
     */
    "policies"?: Array<FeaturePolicy>;
    /**
     * The postal code part of the postal address.
     */
    "postal_code"?: string;
    /**
     * A reason note for updating the status of the account
     */
    "reason"?: string;
    /**
     * A reference note for updating the status of the account
     */
    "reference_note"?: string;
    /**
     * Email address of the sales contact.
     */
    "sales_contact"?: string;
    /**
     * The state part of the postal address.
     */
    "state"?: string;
    /**
     * The status of the account.
     */
    "status": AccountInfo.StatusEnum;
    /**
     * List of sub accounts. Not available for developer users.
     */
    "sub_accounts"?: Array<AccountInfo>;
    /**
     * Account template ID.
     */
    "template_id"?: string;
    /**
     * The tier level of the account; '0': free tier, '1': commercial account, '2': partner tier. Other values are reserved for the future.
     */
    "tier": string;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * Time when upgraded to commercial account in UTC format RFC3339.
     */
    "upgraded_at"?: Date;
}

export namespace AccountInfoList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface AccountInfoList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * A list of entities.
     */
    "data": Array<AccountInfo>;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * Entity name: always 'list'
     */
    "object": AccountInfoList.ObjectEnum;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: AccountInfoList.OrderEnum;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
}

/**
 * This object represents an account creation request.
 */
export namespace AccountUpdateReq {
    export type MfaStatusEnum = "enforced" | "optional";
}
export interface AccountUpdateReq {
    /**
     * Postal address line 1, not longer than 100 characters. Required for commercial accounts only.
     */
    "address_line1"?: string;
    /**
     * Postal address line 2, not longer than 100 characters.
     */
    "address_line2"?: string;
    /**
     * An array of aliases, not more than 10. An alias is not shorter than 8 and not longer than 100 characters.
     */
    "aliases"?: Array<string>;
    /**
     * The city part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "city"?: string;
    /**
     * The name of the company, not longer than 100 characters. Required for commercial accounts only.
     */
    "company"?: string;
    /**
     * The name of the contact person for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "contact"?: string;
    /**
     * The country part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "country"?: string;
    /**
     * Account's custom properties as key-value pairs, with a maximum of 10 keys. The maximum length of a key is 100 characters. The values are handled as strings and the maximum length for a value is 1000 characters.
     */
    "custom_fields"?: { [key: string]: string; };
    /**
     * The display name for the account, not longer than 100 characters.
     */
    "display_name"?: string;
    /**
     * The company email address for this account, not longer than 254 characters. Required for commercial accounts only.
     */
    "email"?: string;
    /**
     * The end market for this account, not longer than 100 characters.
     */
    "end_market"?: string;
    /**
     * Indicates how many days before account expiration a notification email should be sent. Valid values are: 1-180.
     */
    "expiration_warning_threshold"?: string;
    /**
     * The reference token expiration time in minutes for this account. Between 1 and 120 minutes.
     */
    "idle_timeout"?: string;
    /**
     * The enforcement status of setting up the multi-factor authentication. 'Enforced' means that setting up the MFA is required after login. 'Optional' means that the MFA is not required.
     */
    "mfa_status"?: AccountUpdateReq.MfaStatusEnum;
    /**
     * A list of notification email addresses.
     */
    "notification_emails"?: Array<string>;
    /**
     * Password policy for this account.
     */
    "password_policy"?: PasswordPolicy;
    /**
     * The phone number of a representative of the company, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The postal code part of the postal address, not longer than 100 characters.
     */
    "postal_code"?: string;
    /**
     * The state part of the postal address, not longer than 100 characters.
     */
    "state"?: string;
}

/**
 * This object represents an account update request.
 */
export namespace AccountUpdateRootReq {
    export type MfaStatusEnum = "enforced" | "optional";
}
export interface AccountUpdateRootReq {
    /**
     * Postal address line 1, not longer than 100 characters. Required for commercial accounts only.
     */
    "address_line1"?: string;
    /**
     * Postal address line 2, not longer than 100 characters.
     */
    "address_line2"?: string;
    /**
     * An array of aliases, not more than 10. An alias is not shorter than 8 and not longer than 100 characters.
     */
    "aliases"?: Array<string>;
    /**
     * The city part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "city"?: string;
    /**
     * The name of the company, not longer than 100 characters. Required for commercial accounts only.
     */
    "company"?: string;
    /**
     * The name of the contact person for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "contact"?: string;
    /**
     * Contract number of the customer.
     */
    "contract_number"?: string;
    /**
     * The country part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "country"?: string;
    /**
     * Account's custom properties as key-value pairs, with a maximum of 10 keys. The maximum length of a key is 100 characters. The values are handled as strings and the maximum length for a value is 1000 characters.
     */
    "custom_fields"?: { [key: string]: string; };
    /**
     * Customer number of the customer.
     */
    "customer_number"?: string;
    /**
     * The display name for the account, not longer than 100 characters.
     */
    "display_name"?: string;
    /**
     * The company email address for this account, not longer than 254 characters. Required for commercial accounts only.
     */
    "email"?: string;
    /**
     * The end market for this account, not longer than 100 characters.
     */
    "end_market"?: string;
    /**
     * Indicates how many days before account expiration a notification email should be sent. Valid values are: 1-180.
     */
    "expiration_warning_threshold"?: string;
    /**
     * The reference token expiration time in minutes for this account. Between 1 and 120 minutes.
     */
    "idle_timeout"?: string;
    /**
     * The enforcement status of setting up the multi-factor authentication. 'Enforced' means that setting up the MFA is required after login. 'Optional' means that the MFA is not required.
     */
    "mfa_status"?: AccountUpdateRootReq.MfaStatusEnum;
    /**
     * A list of notification email addresses.
     */
    "notification_emails"?: Array<string>;
    /**
     * Password policy for this account.
     */
    "password_policy"?: PasswordPolicy;
    /**
     * The phone number of a representative of the company, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The postal code part of the postal address, not longer than 100 characters.
     */
    "postal_code"?: string;
    /**
     * Email address of the sales contact.
     */
    "sales_contact"?: string;
    /**
     * The state part of the postal address, not longer than 100 characters.
     */
    "state"?: string;
}

/**
 * This object represents an active user session.
 */
export namespace ActiveSession {
    export type ObjectEnum = "user-session";
}
export interface ActiveSession {
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * IP address of the client.
     */
    "ip_address": string;
    /**
     * The login time of the user.
     */
    "login_time": Date;
    /**
     * Entity name: always 'user-session'
     */
    "object": ActiveSession.ObjectEnum;
    /**
     * The reference token.
     */
    "reference_token": string;
    /**
     * User Agent header from the login request.
     */
    "user_agent": string;
}

/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export namespace ApiKeyInfoReq {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface ApiKeyInfoReq {
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
    /**
     * The display name for the API key, not longer than 100 characters.
     */
    "name": string;
    /**
     * The owner of this API key.
     */
    "owner"?: string;
    /**
     * The status of the API key.
     */
    "status"?: ApiKeyInfoReq.StatusEnum;
}

/**
 * This object represents an API key in mbed Cloud.
 */
export namespace ApiKeyInfoResp {
    export type ObjectEnum = "api-key";
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface ApiKeyInfoResp {
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * The timestamp of the API key creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
    /**
     * The UUID of the API key.
     */
    "id": string;
    /**
     * The API key.
     */
    "key": string;
    /**
     * The timestamp of the latest API key usage, in milliseconds.
     */
    "last_login_time"?: number;
    /**
     * The display name for the API key.
     */
    "name": string;
    /**
     * Entity name: always 'api-key'
     */
    "object": ApiKeyInfoResp.ObjectEnum;
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The status of the API key.
     */
    "status"?: ApiKeyInfoResp.StatusEnum;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
}

export namespace ApiKeyInfoRespList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface ApiKeyInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * A list of entities.
     */
    "data": Array<ApiKeyInfoResp>;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * Entity name: always 'list'
     */
    "object": ApiKeyInfoRespList.ObjectEnum;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: ApiKeyInfoRespList.OrderEnum;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
}

/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export namespace ApiKeyUpdateReq {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface ApiKeyUpdateReq {
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
    /**
     * The display name for the API key, not longer than 100 characters.
     */
    "name": string;
    /**
     * The owner of this API key.
     */
    "owner"?: string;
    /**
     * The status of the API key.
     */
    "status"?: ApiKeyUpdateReq.StatusEnum;
}

/**
 * This object represents an error message.
 */
export namespace ErrorResponse {
    export type ObjectEnum = "error";
    export type TypeEnum = "success" | "created" | "accepted" | "permanently_deleted" | "validation_error" | "invalid_token" | "invalid_apikey" | "reauth_required" | "access_denied" | "account_limit_exceeded" | "not_found" | "method_not_supported" | "not_acceptable" | "duplicate" | "precondition_failed" | "unsupported_media_type" | "rate_limit_exceeded" | "internal_server_error" | "system_unavailable";
}
export interface ErrorResponse {
    /**
     * Response code.
     */
    "code": number;
    /**
     * Failed input fields during request object validation.
     */
    "fields"?: Array<Field>;
    /**
     * A human readable message with detailed info.
     */
    "message": string;
    /**
     * Entity name, always 'error'.
     */
    "object": ErrorResponse.ObjectEnum;
    /**
     * Request ID.
     */
    "request_id": string;
    /**
     * Error type.
     */
    "type": ErrorResponse.TypeEnum;
}

/**
 * This object represents a feature policy. Either the feature or the resource must be specified.
 */
export interface FeaturePolicy {
    /**
     * Comma separated list of actions, empty string represents all actions.
     */
    "action"?: string;
    /**
     * True or false controlling whether an action is allowed or not.
     */
    "allow"?: boolean;
    /**
     * Feature name corresponding to this policy.
     */
    "feature"?: string;
    /**
     * Flag indicating whether this feature is inherited or overwritten specifically.
     */
    "inherited"?: boolean;
    /**
     * Resource that is protected by this policy.
     */
    "resource"?: string;
}

export interface Field {
    /**
     * Message describing the erroneous situation.
     */
    "message": string;
    /**
     * Name of the erroneous field.
     */
    "name": string;
}

/**
 * This object is used when creating new groups.
 */
export interface GroupCreationInfo {
    /**
     * The members of the group as arrays of user and API key UUIDs.
     */
    "members"?: SubjectList;
    /**
     * The group name, not longer than 100 characters.
     */
    "name": string;
}

/**
 * This object contains basic information about groups.
 */
export namespace GroupSummary {
    export type ObjectEnum = "group";
}
export interface GroupSummary {
    /**
     * The UUID of the account this group belongs to.
     */
    "account_id": string;
    /**
     * The number of API keys in this group.
     */
    "apikey_count": number;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The UUID of the group.
     */
    "id": string;
    /**
     * The name of the group.
     */
    "name": string;
    /**
     * Entity name: always 'group'
     */
    "object": GroupSummary.ObjectEnum;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * The number of users in this group.
     */
    "user_count": number;
}

export namespace GroupSummaryList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface GroupSummaryList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * A list of entities.
     */
    "data": Array<GroupSummary>;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * Entity name: always 'list'
     */
    "object": GroupSummaryList.ObjectEnum;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: GroupSummaryList.OrderEnum;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
}

/**
 * This object is used when updating groups.
 */
export interface GroupUpdateInfo {
    /**
     * The group name, not longer than 100 characters.
     */
    "name": string;
}

/**
 * This object represents an entry in login history.
 */
export interface LoginHistory {
    /**
     * UTC time RFC3339 for this login attempt.
     */
    "date": Date;
    /**
     * IP address of the client.
     */
    "ip_address": string;
    /**
     * Flag indicating whether login attempt was successful or not.
     */
    "success": boolean;
    /**
     * User Agent header from the login request.
     */
    "user_agent": string;
}

export interface PasswordPolicy {
    /**
     * Minimum length for the password. A number between 8 and 512.
     */
    "minimum_length": string;
}

/**
 * This object represents arrays of user and API key IDs.
 */
export interface SubjectList {
    /**
     * An array of API key IDs.
     */
    "apikeys"?: Array<string>;
    /**
     * An array of user IDs.
     */
    "users"?: Array<string>;
}

/**
 * This object represents a trusted certificate in responses.
 */
export namespace TrustedCertificateInternalResp {
    export type ObjectEnum = "trusted-cert";
    export type ServiceEnum = "lwm2m" | "bootstrap";
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface TrustedCertificateInternalResp {
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * X509.v3 trusted certificate in PEM format.
     */
    "certificate": string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Human readable description of this certificate.
     */
    "description"?: string;
    /**
     * Device execution mode where 1 means a developer certificate.
     */
    "device_execution_mode"?: number;
    /**
     * If true, signature is not required. Default value false.
     */
    "enrollment_mode"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Entity ID.
     */
    "id": string;
    /**
     * Issuer of the certificate.
     */
    "issuer": string;
    /**
     * Certificate name.
     */
    "name": string;
    /**
     * Entity name: always 'trusted-cert'
     */
    "object": TrustedCertificateInternalResp.ObjectEnum;
    /**
     * The UUID of the owner.
     */
    "owner_id"?: string;
    /**
     * Private key of the certificate in PEM or base64 encoded DER format.
     */
    "private_key": string;
    /**
     * Service name where the certificate is to be used.
     */
    "service": TrustedCertificateInternalResp.ServiceEnum;
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateInternalResp.StatusEnum;
    /**
     * Subject of the certificate.
     */
    "subject": string;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * Expiration time in UTC formatted as RFC3339.
     */
    "validity": Date;
}

export namespace TrustedCertificateInternalRespList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface TrustedCertificateInternalRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * A list of entities.
     */
    "data": Array<TrustedCertificateInternalResp>;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * Entity name: always 'list'
     */
    "object": TrustedCertificateInternalRespList.ObjectEnum;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: TrustedCertificateInternalRespList.OrderEnum;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
}

/**
 * This object represents a trusted certificate in upload requests.
 */
export namespace TrustedCertificateReq {
    export type ServiceEnum = "lwm2m" | "bootstrap";
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface TrustedCertificateReq {
    /**
     * A chain of X509.v3 trusted certificates in PEM format. The chain must contain all certificates from root to leaf. Otherwise, the signature parameter is required.
     */
    "certificate": string;
    /**
     * Human readable description of this certificate, not longer than 500 characters.
     */
    "description"?: string;
    /**
     * Certificate is used in enrollment mode. Default value is false.
     */
    "enrollment_mode"?: boolean;
    /**
     * Certificate name, not longer than 100 characters.
     */
    "name": string;
    /**
     * Service name where the certificate must be used.
     */
    "service": TrustedCertificateReq.ServiceEnum;
    /**
     * DEPRECATED: Base64 encoded signature of the account ID signed by the certificate to be uploaded. The signature must be hashed with SHA256. Needed when uploading an interim certificate without the full chain.
     */
    "signature"?: string;
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateReq.StatusEnum;
}

/**
 * This object represents a trusted certificate in responses.
 */
export namespace TrustedCertificateResp {
    export type ObjectEnum = "trusted-cert";
    export type ServiceEnum = "lwm2m" | "bootstrap";
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface TrustedCertificateResp {
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * X509.v3 trusted certificate in PEM format.
     */
    "certificate": string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Human readable description of this certificate.
     */
    "description"?: string;
    /**
     * Device execution mode where 1 means a developer certificate.
     */
    "device_execution_mode"?: number;
    /**
     * If true, signature is not required. Default value false.
     */
    "enrollment_mode"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Entity ID.
     */
    "id": string;
    /**
     * Issuer of the certificate.
     */
    "issuer": string;
    /**
     * Certificate name.
     */
    "name": string;
    /**
     * Entity name: always 'trusted-cert'
     */
    "object": TrustedCertificateResp.ObjectEnum;
    /**
     * The UUID of the owner.
     */
    "owner_id"?: string;
    /**
     * Service name where the certificate is to be used.
     */
    "service": TrustedCertificateResp.ServiceEnum;
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateResp.StatusEnum;
    /**
     * Subject of the certificate.
     */
    "subject": string;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * Expiration time in UTC formatted as RFC3339.
     */
    "validity": Date;
}

export namespace TrustedCertificateRespList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface TrustedCertificateRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * A list of entities.
     */
    "data": Array<TrustedCertificateResp>;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * Entity name: always 'list'
     */
    "object": TrustedCertificateRespList.ObjectEnum;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: TrustedCertificateRespList.OrderEnum;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
}

/**
 * This object represents a trusted certificate in upload requests.
 */
export namespace TrustedCertificateRootReq {
    export type ServiceEnum = "lwm2m" | "bootstrap";
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface TrustedCertificateRootReq {
    /**
     * A chain of X509.v3 trusted certificates in PEM format. The chain must contain all certificates from root to leaf. Otherwise, the signature parameter is required.
     */
    "certificate": string;
    /**
     * Human readable description of this certificate, not longer than 500 characters.
     */
    "description"?: string;
    /**
     * Certificate is used in enrollment mode. Default value is false.
     */
    "enrollment_mode"?: boolean;
    /**
     * Certificate name, not longer than 100 characters.
     */
    "name": string;
    /**
     * Service name where the certificate must be used.
     */
    "service": TrustedCertificateRootReq.ServiceEnum;
    /**
     * DEPRECATED: Base64 encoded signature of the account ID signed by the certificate to be uploaded. The signature must be hashed with SHA256. Needed when uploading an interim certificate without the full chain.
     */
    "signature"?: string;
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateRootReq.StatusEnum;
}

/**
 * This object represents a trusted certificate in update requests.
 */
export namespace TrustedCertificateUpdateReq {
    export type ServiceEnum = "lwm2m" | "bootstrap";
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface TrustedCertificateUpdateReq {
    /**
     * A chain of X509.v3 trusted certificates in PEM format. The chain must contain all certificates from root to leaf. Otherwise, the signature parameter is required.
     */
    "certificate"?: string;
    /**
     * Human readable description of this certificate, not longer than 500 characters.
     */
    "description"?: string;
    /**
     * Certificate is used in enrollment mode. Default value is false.
     */
    "enrollment_mode"?: boolean;
    /**
     * Certificate name, not longer than 100 characters.
     */
    "name"?: string;
    /**
     * Service name where the certificate must be used.
     */
    "service"?: TrustedCertificateUpdateReq.ServiceEnum;
    /**
     * DEPRECATED: Base64 encoded signature of the account ID signed by the certificate to be uploaded. The signature must be hashed with SHA256. Needed when uploading an interim certificate without the full chain.
     */
    "signature"?: string;
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateUpdateReq.StatusEnum;
}

/**
 * This object represents a response to an update request.
 */
export namespace UpdatedResponse {
    export type ObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error" | "policy" | "identity-provider" | "user-session";
    export type TypeEnum = "success";
}
export interface UpdatedResponse {
    /**
     * Response code.
     */
    "code": number;
    /**
     * Entity ID.
     */
    "id": string;
    /**
     * A human readable message with detailed info.
     */
    "message": string;
    /**
     * Entity name: 'user', 'apikey', 'group', 'policy' or 'account'.
     */
    "object": UpdatedResponse.ObjectEnum;
    /**
     * Request ID.
     */
    "request_id": string;
    /**
     * Response type: success.
     */
    "type": UpdatedResponse.TypeEnum;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserInfoReq {
    /**
     * Address, not longer than 100 characters.
     */
    "address"?: string;
    /**
     * User's account-specific custom properties as key-value pairs, with a maximum of 10 keys. The maximum length of a key is 100 characters. The values are handled as strings and the maximum length for a value is 1000 characters.
     */
    "custom_fields"?: { [key: string]: string; };
    /**
     * The email address, not longer than 254 characters.
     */
    "email": string;
    /**
     * The full name of the user, not longer than 100 characters.
     */
    "full_name"?: string;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "password"?: string;
    /**
     * Phone number, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * A username containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "username"?: string;
}

/**
 * This object represents a user in mbed Cloud.
 */
export namespace UserInfoResp {
    export type ObjectEnum = "user";
    export type StatusEnum = "ENROLLING" | "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
}
export interface UserInfoResp {
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * User's account specific custom properties. The value is a string.
     */
    "custom_fields"?: { [key: string]: string; };
    /**
     * The email address.
     */
    "email": string;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * A flag indicating whether 2-factor authentication (TOTP) has been enabled.
     */
    "is_totp_enabled"?: boolean;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
    /**
     * Timestamps, succeedings, IP addresses and user agent information of the last five logins of the user, with timestamps in RFC3339 format.
     */
    "login_history"?: Array<LoginHistory>;
    /**
     * Entity name: always 'user'
     */
    "object": UserInfoResp.ObjectEnum;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "password"?: string;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The status of the user. ENROLLING state indicates that the user is in the middle of the enrollment process. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately. INACTIVE users are locked out and not permitted to use the system.
     */
    "status": UserInfoResp.StatusEnum;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username"?: string;
}

export namespace UserInfoRespList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface UserInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * A list of entities.
     */
    "data": Array<UserInfoResp>;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * Entity name: always 'list'
     */
    "object": UserInfoRespList.ObjectEnum;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: UserInfoRespList.OrderEnum;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserUpdateReq {
    /**
     * Address, not longer than 100 characters.
     */
    "address"?: string;
    /**
     * User's account specific custom properties, with a maximum of 10 keys. The maximum length of a key is 100 characters. The values are handled as strings and the maximum length for a value is 1000 characters.
     */
    "custom_fields"?: { [key: string]: string; };
    /**
     * The email address, not longer than 254 characters.
     */
    "email"?: string;
    /**
     * The full name of the user, not longer than 100 characters.
     */
    "full_name"?: string;
    /**
     * A list of group IDs this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * A flag indicating whether 2-factor authentication (TOTP) has to be enabled or disabled.
     */
    "is_totp_enabled"?: boolean;
    /**
     * Phone number, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The status of the user.
     */
    "status"?: string;
    /**
     * A username containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "username"?: string;
}

/**
 * This object represents a user update response.
 */
export namespace UserUpdateResp {
    export type ObjectEnum = "user";
    export type StatusEnum = "ENROLLING" | "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
}
export interface UserUpdateResp {
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * List of active user sessions.
     */
    "active_sessions"?: Array<ActiveSession>;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * User's account specific custom properties. The value is a string.
     */
    "custom_fields"?: { [key: string]: string; };
    /**
     * The email address.
     */
    "email": string;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * A flag indicating whether 2-factor authentication (TOTP) has been enabled.
     */
    "is_totp_enabled"?: boolean;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
    /**
     * Timestamps, succeedings, IP addresses and user agent information of the last five logins of the user, with timestamps in RFC3339 format.
     */
    "login_history"?: Array<LoginHistory>;
    /**
     * Entity name: always 'user'
     */
    "object": UserUpdateResp.ObjectEnum;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "password"?: string;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The status of the user. ENROLLING state indicates that the user is in the middle of the enrollment process. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately. INACTIVE users are locked out and not permitted to use the system.
     */
    "status": UserUpdateResp.StatusEnum;
    /**
     * A list of scratch codes for the 2-factor authentication. Visible only when 2FA is requested to be enabled or the codes regenerated.
     */
    "totp_scratch_codes"?: Array<string>;
    /**
     * Secret for the 2-factor authenticator app. Visible only when 2FA is requested to be enabled.
     */
    "totp_secret"?: string;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username"?: string;
}

/**
 * AccountAdminApi
 */
export class AccountAdminApi extends ApiBase {

    /**
     * Add API key to a list of groups.
     * An endpoint for adding API key to groups.   **Example usage:** &#x60;curl -X POST https://api.us-east-1.mbedcloud.com/v3/api-keys/{apikey-id}/groups -d &#39;[0162056a9a1586f30242590700000000,0117056a9a1586f30242590700000000]&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param apiKey The ID of the API key to be added to the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public addApiKeyToGroups(apiKey: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/api-keys/{apiKey}/groups".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Upload a new trusted certificate.
     * An endpoint for uploading new trusted certificates.   **Example usage:** &#x60;curl -X POST https://api.us-east-1.mbedcloud.com/v3/trusted-certificates -d {\&quot;name\&quot;: \&quot;myCert1\&quot;, \&quot;description\&quot;: \&quot;very important cert\&quot;, \&quot;certificate\&quot;: \&quot;certificate_data\&quot;, \&quot;service\&quot;: \&quot;lwm2m\&quot;} -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body A trusted certificate object with attributes.
     */
    public addCertificate(body: TrustedCertificateReq, callback?: (error: any, data?: TrustedCertificateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateResp>({
            url: "/v3/trusted-certificates",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Add members to a group.
     * An endpoint for adding users and API keys to a group.   **Example usage:** &#x60;curl -X POST https://api.us-east-1.mbedcloud.com/v3/policy-groups/{group-id} -d &#39;{\&quot;users\&quot;: [0162056a9a1586f30242590700000000,0117056a9a1586f30242590700000000]\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param groupID The ID of the group to be updated.
     * @param body A list of users and API keys to be added to the group.
     */
    public addSubjectsToGroup(groupID: string, body: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/policy-groups/{groupID}".replace("{" + "groupID" + "}", String(groupID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Add user to a list of groups.
     * An endpoint for adding user to groups.   **Example usage:** &#x60;curl -X POST https://api.us-east-1.mbedcloud.com/v3/users/{user-id}/groups -d &#39;[0162056a9a1586f30242590700000000,0117056a9a1586f30242590700000000]&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param userId The ID of the user to be added to the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public addUserToGroups(userId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/users/{user-id}/groups".replace("{" + "user-id" + "}", String(userId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new group.
     * An endpoint for creating a new group.   **Example usage:** &#x60;curl -X POST https://api.us-east-1.mbedcloud.com/v3/policy-groups -d &#39;{\&quot;name\&quot;: \&quot;MyGroup1\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body Details of the group to be created.
     */
    public createGroup(body: GroupCreationInfo, callback?: (error: any, data?: GroupSummary, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummary>({
            url: "/v3/policy-groups",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new user.
     * An endpoint for creating or inviting a new user to the account. In case of invitation email address is used only, other attributes are set in the 2nd step.   **Example usage:** &#x60;curl -X POST https://api.us-east-1.mbedcloud.com/v3/users?action&#x3D;invite -d {\&quot;email\&quot;: \&quot;myemail@company.com\&quot;} -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body A user object with attributes.
     * @param action Action, either &#39;create&#39; or &#39;invite&#39;.
     */
    public createUser(body: UserInfoReq, action?: string, callback?: (error: any, data?: UserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (action !== undefined) {
            queryParameters["action"] = action;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoResp>({
            url: "/v3/users",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Delete a group.
     * An endpoint for deleting a group.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/policy-groups/{group-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param groupID The ID of the group to be deleted.
     */
    public deleteGroup(groupID: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/policy-groups/{groupID}".replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete a user.
     * An endpoint for deleting a user.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/users/{user-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param userId The ID of the user to be deleted.
     */
    public deleteUser(userId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/users/{user-id}".replace("{" + "user-id" + "}", String(userId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get the details of all users.
     * An endpoint for retrieving the details of all users.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/users -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param emailEq Filter for email address
     * @param statusEq Filter for status, for example active or reset
     * @param statusIn An optional filter for getting users with a specified set of statuses.
     * @param statusNin An optional filter for excluding users with a specified set of statuses.
     */
    public getAllUsers(limit?: number, after?: string, order?: string, include?: string, emailEq?: string, statusEq?: string, statusIn?: string, statusNin?: string, callback?: (error: any, data?: UserInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (emailEq !== undefined) {
            queryParameters["email__eq"] = emailEq;
        }
        if (statusEq !== undefined) {
            queryParameters["status__eq"] = statusEq;
        }
        if (statusIn !== undefined) {
            queryParameters["status__in"] = statusIn;
        }
        if (statusNin !== undefined) {
            queryParameters["status__nin"] = statusNin;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoRespList>({
            url: "/v3/users",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the API key.
     * An endpoint for retrieving groups of the API key.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/api-keys/{apikey-id}/groups -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param apiKey The ID of the API key whose details are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfApikey(apiKey: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/api-keys/{apiKey}/groups".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the user.
     * An endpoint for retrieving groups of the user.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/users/{user-id}/groups -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param userId The ID of the user whose details are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfUser(userId: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/users/{user-id}/groups".replace("{" + "user-id" + "}", String(userId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Details of a user.
     * An endpoint for retrieving the details of a user.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/users/{user-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param userId The ID of the user whose details are retrieved.
     * @param properties Request to return account specific user property values according to the given property name.
     */
    public getUser(userId: string, properties?: string, callback?: (error: any, data?: UserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoResp>({
            url: "/v3/users/{user-id}".replace("{" + "user-id" + "}", String(userId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get users of a group.
     * An endpoint for listing the users of a group with details.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/policy-groups/{group-id}/users -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param groupID The ID of the group whose users are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param statusEq An optional filter for getting users by status.
     * @param statusIn An optional filter for getting users with a specified set of statuses.
     * @param statusNin An optional filter for excluding users with a specified set of statuses.
     */
    public getUsersOfGroup(groupID: string, limit?: number, after?: string, order?: string, include?: string, statusEq?: string, statusIn?: string, statusNin?: string, callback?: (error: any, data?: UserInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (statusEq !== undefined) {
            queryParameters["status__eq"] = statusEq;
        }
        if (statusIn !== undefined) {
            queryParameters["status__in"] = statusIn;
        }
        if (statusNin !== undefined) {
            queryParameters["status__nin"] = statusNin;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoRespList>({
            url: "/v3/policy-groups/{groupID}/users".replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Remove API key from groups.
     * An endpoint for removing API key from groups.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/api-keys/{apikey-id}/groups -d &#39;[0162056a9a1586f30242590700000000,0117056a9a1586f30242590700000000]&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param apiKey The ID of the API key to be removed from the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeApiKeyFromGroups(apiKey: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/api-keys/{apiKey}/groups".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove user from groups.
     * An endpoint for removing user from groups.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/users/{user-id}/groups -d &#39;[0162056a9a1586f30242590700000000,0117056a9a1586f30242590700000000]&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param userId The ID of the user to be removed from the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeUserFromGroups(userId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/users/{user-id}/groups".replace("{" + "user-id" + "}", String(userId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove users from a group.
     * An endpoint for removing users from groups.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/policy-groups/{group-id}/users -d &#39;[0162056a9a1586f30242590700000000,0117056a9a1586f30242590700000000]&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param groupID The ID of the group whose users are removed.
     * @param body A list of users to be removed from the group.
     */
    public removeUsersFromGroup(groupID: string, body: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/policy-groups/{groupID}/users".replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update the group name.
     * An endpoint for updating a group name.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/policy-groups/{group-id} -d &#39;{\&quot;name\&quot;: \&quot;TestGroup2\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param groupID The ID of the group to be updated.
     * @param body Details of the group to be created.
     */
    public updateGroupName(groupID: string, body: GroupUpdateInfo, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/policy-groups/{groupID}".replace("{" + "groupID" + "}", String(groupID)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Updates attributes of the account.
     * An endpoint for updating the account.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/accounts/me -d &#39;{\&quot;phone_number\&quot;: \&quot;12345678\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body Details of the account to be updated.
     */
    public updateMyAccount(body: AccountUpdateReq, callback?: (error: any, data?: AccountInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfo>({
            url: "/v3/accounts/me",
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update user details.
     * An endpoint for updating user details.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/users/{user-id} -d &#39;{\&quot;username\&quot;: \&quot;myusername\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param userId The ID of the user whose details are updated.
     * @param body A user object with attributes.
     */
    public updateUser(userId: string, body: UserUpdateReq, callback?: (error: any, data?: UserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoResp>({
            url: "/v3/users/{user-id}".replace("{" + "user-id" + "}", String(userId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
}
/**
 * AggregatorAccountAdminApi
 */
export class AggregatorAccountAdminApi extends ApiBase {

    /**
     * Add API key to a list of groups.
     * An endpoint for adding API key to groups.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be added to the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public addAccountApiKeyToGroups(accountID: string, apiKey: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Upload new trusted certificate.
     * An endpoint for uploading new trusted certificates.
     * @param accountID Account ID.
     * @param body A trusted certificate object with attributes, signature is optional.
     */
    public addAccountCertificate(accountID: string, body: TrustedCertificateRootReq, callback?: (error: any, data?: TrustedCertificateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateResp>({
            url: "/v3/accounts/{accountID}/trusted-certificates".replace("{" + "accountID" + "}", String(accountID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Add user to a list of groups.
     * An endpoint for adding user to groups.
     * @param accountID Account ID.
     * @param userId The ID of the user to be added to the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public addAccountUserToGroups(accountID: string, userId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/users/{user-id}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Add members to a group.
     * An endpoint for adding users and API keys to groups.
     * @param accountID Account ID.
     * @param groupID The ID of the group to be updated.
     * @param body A list of users and API keys to be added to the group.
     */
    public addSubjectsToAccountGroup(accountID: string, groupID: string, body: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Check the API key.
     * An endpoint for checking API key.
     * @param accountID Account ID.
     * @param apiKey The API key to be checked.
     */
    public checkAccountApiKey(accountID: string, apiKey: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Create a new account.
     * An endpoint for creating a new account.
     * @param body Details of the account to be created.
     * @param action Action, either &#39;create&#39; or &#39;enroll&#39;. &lt;ul&gt;&lt;li&gt;&#39;create&#39; creates the account where its admin user has ACTIVE status if admin_password was defined in the request, or RESET status if no admin_password was defined. If the user already exists, its status is not modified. &lt;/li&gt;&lt;li&gt;&#39;enroll&#39; creates the account where its admin user has ENROLLING status. If the user already exists, its status is not modified. Email to finish the enrollment or to notify the existing user about the new account is sent to the admin_email defined in the request. &lt;/li&gt;&lt;/ul&gt;
     */
    public createAccount(body: AccountCreationReq, action?: string, callback?: (error: any, data?: AccountCreationResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (action !== undefined) {
            queryParameters["action"] = action;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountCreationResp>({
            url: "/v3/accounts",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new API key.
     * An endpoint for creating a new API key. There is no default value for the owner ID and it must be from the same account where the new API key is created.
     * @param accountID Account ID.
     * @param body Details of the API key to be created.
     */
    public createAccountApiKey(accountID: string, body: ApiKeyInfoReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/accounts/{accountID}/api-keys".replace("{" + "accountID" + "}", String(accountID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new group.
     * An endpoint for creating a new group.
     * @param accountID Account ID.
     * @param body Details of the group to be created.
     */
    public createAccountGroup(accountID: string, body: GroupCreationInfo, callback?: (error: any, data?: GroupSummary, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummary>({
            url: "/v3/accounts/{accountID}/policy-groups".replace("{" + "accountID" + "}", String(accountID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new user.
     * An endpoint for creating or inviting a new user to the account. In case of invitation email address is used only, other attributes are set in the 2nd step.
     * @param accountID Account ID.
     * @param body A user object with attributes.
     * @param action Create or invite user.
     */
    public createAccountUser(accountID: string, body: UserInfoReq, action?: string, callback?: (error: any, data?: UserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (action !== undefined) {
            queryParameters["action"] = action;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoResp>({
            url: "/v3/accounts/{accountID}/users".replace("{" + "accountID" + "}", String(accountID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Delete the API key.
     * An endpoint for deleting an API key.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be deleted.
     */
    public deleteAccountApiKey(accountID: string, apiKey: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete trusted certificate by ID.
     * An endpoint for deleting the trusted certificate.
     * @param accountID Account ID.
     * @param certId The ID of the trusted certificate to be deleted.
     */
    public deleteAccountCertificate(accountID: string, certId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/trusted-certificates/{cert-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "cert-id" + "}", String(certId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete a group.
     * An endpoint for deleting a group.
     * @param accountID Account ID.
     * @param groupID The ID of the group to be deleted.
     */
    public deleteAccountGroup(accountID: string, groupID: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete a user.
     * An endpoint for deleting a user.
     * @param accountID Account ID.
     * @param userId The ID of the user to be deleted.
     */
    public deleteAccountUser(accountID: string, userId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/users/{user-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be retrieved.
     */
    public getAccountApiKey(accountID: string, apiKey: string, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get trusted certificate by ID.
     * An endpoint for retrieving a trusted certificate by ID.
     * @param accountID Account ID.
     * @param certId The ID of the trusted certificate to be retrieved.
     */
    public getAccountCertificate(accountID: string, certId: string, callback?: (error: any, data?: TrustedCertificateInternalResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateInternalResp>({
            url: "/v3/accounts/{accountID}/trusted-certificates/{cert-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "cert-id" + "}", String(certId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get group information.
     * An endpoint for getting general information about the group.
     * @param accountID Account ID.
     * @param groupID The ID of the group to be retrieved.
     */
    public getAccountGroupSummary(accountID: string, groupID: string, callback?: (error: any, data?: GroupSummary, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummary>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get account info.
     * Returns detailed information about the account.
     * @param accountID The ID of the account to be fetched.
     * @param include Comma separated additional data to return. Currently supported: limits, policies, sub_accounts
     * @param properties Property name to be returned from account specific properties.
     */
    public getAccountInfo(accountID: string, include?: string, properties?: string, callback?: (error: any, data?: AccountInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfo>({
            url: "/v3/accounts/{accountID}".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Details of the user.
     * An endpoint for retrieving details of the user.
     * @param accountID Account ID.
     * @param userId The ID of the user to be retrieved.
     * @param properties Request to return account specific user property values according to the given property name.
     */
    public getAccountUser(accountID: string, userId: string, properties?: string, callback?: (error: any, data?: UserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoResp>({
            url: "/v3/accounts/{accountID}/users/{user-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all API keys.
     * An endpoint for retrieving the API keys in an array, optionally filtered by the owner.
     * @param accountID Account ID.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param keyEq API key filter.
     * @param ownerEq Owner name filter.
     */
    public getAllAccountApiKeys(accountID: string, limit?: number, after?: string, order?: string, include?: string, keyEq?: string, ownerEq?: string, callback?: (error: any, data?: ApiKeyInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (keyEq !== undefined) {
            queryParameters["key__eq"] = keyEq;
        }
        if (ownerEq !== undefined) {
            queryParameters["owner__eq"] = ownerEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoRespList>({
            url: "/v3/accounts/{accountID}/api-keys".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all trusted certificates.
     * An endpoint for retrieving trusted certificates in an array.
     * @param accountID Account ID.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param nameEq Filter for certificate name
     * @param serviceEq Filter for service
     * @param expireEq Filter for expire
     * @param deviceExecutionModeEq Filter for developer certificates
     * @param deviceExecutionModeNeq Filter for not developer certificates
     * @param ownerEq Owner name filter
     * @param enrollmentModeEq Enrollment mode filter
     * @param issuerLike Filter for issuer. Finds all matches where the filter value is a case insensitive substring of the result. Example: issuer__like&#x3D;cn&#x3D;iss matches CN&#x3D;issuer.
     * @param subjectLike Filter for subject. Finds all matches where the filter value is a case insensitive substring of the result. Example: subject__like&#x3D;cn&#x3D;su matches CN&#x3D;subject.
     */
    public getAllAccountCertificates(accountID: string, limit?: number, after?: string, order?: string, include?: string, nameEq?: string, serviceEq?: string, expireEq?: number, deviceExecutionModeEq?: number, deviceExecutionModeNeq?: number, ownerEq?: string, enrollmentModeEq?: boolean, issuerLike?: string, subjectLike?: string, callback?: (error: any, data?: TrustedCertificateInternalRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (nameEq !== undefined) {
            queryParameters["name__eq"] = nameEq;
        }
        if (serviceEq !== undefined) {
            queryParameters["service__eq"] = serviceEq;
        }
        if (expireEq !== undefined) {
            queryParameters["expire__eq"] = expireEq;
        }
        if (deviceExecutionModeEq !== undefined) {
            queryParameters["device_execution_mode__eq"] = deviceExecutionModeEq;
        }
        if (deviceExecutionModeNeq !== undefined) {
            queryParameters["device_execution_mode__neq"] = deviceExecutionModeNeq;
        }
        if (ownerEq !== undefined) {
            queryParameters["owner__eq"] = ownerEq;
        }
        if (enrollmentModeEq !== undefined) {
            queryParameters["enrollment_mode__eq"] = enrollmentModeEq;
        }
        if (issuerLike !== undefined) {
            queryParameters["issuer__like"] = issuerLike;
        }
        if (subjectLike !== undefined) {
            queryParameters["subject__like"] = subjectLike;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateInternalRespList>({
            url: "/v3/accounts/{accountID}/trusted-certificates".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all group information.
     * An endpoint for retrieving all group information.
     * @param accountID Account ID.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param nameEq Filter for group name
     */
    public getAllAccountGroups(accountID: string, limit?: number, after?: string, order?: string, include?: string, nameEq?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (nameEq !== undefined) {
            queryParameters["name__eq"] = nameEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/accounts/{accountID}/policy-groups".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all user details.
     * An endpoint for retrieving details of all users.
     * @param accountID Account ID.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param emailEq Filter for email address
     * @param statusEq Filter for status
     * @param statusIn An optional filter for getting users with a specified set of statuses.
     * @param statusNin An optional filter for excluding users with a specified set of statuses.
     */
    public getAllAccountUsers(accountID: string, limit?: number, after?: string, order?: string, include?: string, emailEq?: string, statusEq?: string, statusIn?: string, statusNin?: string, callback?: (error: any, data?: UserInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (emailEq !== undefined) {
            queryParameters["email__eq"] = emailEq;
        }
        if (statusEq !== undefined) {
            queryParameters["status__eq"] = statusEq;
        }
        if (statusIn !== undefined) {
            queryParameters["status__in"] = statusIn;
        }
        if (statusNin !== undefined) {
            queryParameters["status__nin"] = statusNin;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoRespList>({
            url: "/v3/accounts/{accountID}/users".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all accounts.
     * Returns an array of account objects, optionally filtered by status and tier level.
     * @param statusEq An optional filter for account status, ENROLLING, ACTIVE, RESTRICTED or SUSPENDED.
     * @param statusIn An optional filter for getting accounts with a specified set of statuses.
     * @param statusNin An optional filter for excluding accounts with a specified set of statuses.
     * @param tierEq An optional filter for tier level, must be 0, 1, 2, 98, 99 or omitted.
     * @param parentEq An optional filter for parent account ID.
     * @param endMarketEq An optional filter for account end market.
     * @param countryLike An optional filter for account country. Finds all matches where the filter value is a case insensitive substring of the result. Example: country__like&#x3D;LAND matches Ireland.
     * @param limit The number of results to return (2-1000), default is 1000.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC. Default value is ASC
     * @param include Comma separated additional data to return. Currently supported: limits, policies, sub_accounts
     * @param format Format information for the response to the query, supported: format&#x3D;breakdown.
     * @param properties Property name to be returned from account specific properties.
     */
    public getAllAccounts(statusEq?: string, statusIn?: string, statusNin?: string, tierEq?: string, parentEq?: string, endMarketEq?: string, countryLike?: string, limit?: number, after?: string, order?: string, include?: string, format?: string, properties?: string, callback?: (error: any, data?: AccountInfoList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (statusEq !== undefined) {
            queryParameters["status__eq"] = statusEq;
        }
        if (statusIn !== undefined) {
            queryParameters["status__in"] = statusIn;
        }
        if (statusNin !== undefined) {
            queryParameters["status__nin"] = statusNin;
        }
        if (tierEq !== undefined) {
            queryParameters["tier__eq"] = tierEq;
        }
        if (parentEq !== undefined) {
            queryParameters["parent__eq"] = parentEq;
        }
        if (endMarketEq !== undefined) {
            queryParameters["end_market__eq"] = endMarketEq;
        }
        if (countryLike !== undefined) {
            queryParameters["country__like"] = countryLike;
        }
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (format !== undefined) {
            queryParameters["format"] = format;
        }
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfoList>({
            url: "/v3/accounts",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get API keys of a group.
     * An endpoint for listing the API keys of the group with details.
     * @param accountID Account ID.
     * @param groupID The ID of the group whose API keys are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getApiKeysOfAccountGroup(accountID: string, groupID: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: ApiKeyInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoRespList>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}/api-keys".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the API key.
     * An endpoint for retrieving groups of the API key.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key whose details are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfAccountApikey(accountID: string, apiKey: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the user.
     * An endpoint for retrieving groups of the user.
     * @param accountID Account ID.
     * @param userId The ID of the user whose details are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfAccountUser(accountID: string, userId: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/accounts/{accountID}/users/{user-id}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get users of a group.
     * An endpoint for listing users of the group with details.
     * @param accountID Account ID.
     * @param groupID The ID of the group whose users are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param statusEq An optional filter for getting users by status.
     * @param statusIn An optional filter for getting users with a specified set of statuses.
     * @param statusNin An optional filter for excluding users with a specified set of statuses.
     */
    public getUsersOfAccountGroup(accountID: string, groupID: string, limit?: number, after?: string, order?: string, include?: string, statusEq?: string, statusIn?: string, statusNin?: string, callback?: (error: any, data?: UserInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (statusEq !== undefined) {
            queryParameters["status__eq"] = statusEq;
        }
        if (statusIn !== undefined) {
            queryParameters["status__in"] = statusIn;
        }
        if (statusNin !== undefined) {
            queryParameters["status__nin"] = statusNin;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoRespList>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}/users".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Remove API key from groups.
     * An endpoint for removing API key from groups.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be removed from the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeAccountApiKeyFromGroups(accountID: string, apiKey: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove user from groups.
     * An endpoint for removing user from groups.
     * @param accountID Account ID.
     * @param userId The ID of the user to be removed from the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeAccountUserFromGroups(accountID: string, userId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/users/{user-id}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove API keys from a group.
     * An endpoint for removing API keys from groups.
     * @param accountID Account ID.
     * @param groupID A list of API keys to be removed from the group.
     * @param body 
     */
    public removeApiKeysFromAccountGroup(accountID: string, groupID: string, body?: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}/api-keys".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove users from a group.
     * An endpoint for removing users from groups.
     * @param accountID Account ID.
     * @param groupID 
     * @param body 
     */
    public removeUsersFromAccountGroup(accountID: string, groupID: string, body?: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}/users".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Reset the secret key.
     * An endpoint for resetting the secret key of the API key.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be reset.
     */
    public resetAccountApiKeySecret(accountID: string, apiKey: string, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}/reset-secret".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Update attributes of an existing account.
     * An endpoint for updating an account.
     * @param accountID The ID of the account to be updated.
     * @param body Details of the account to be updated.
     */
    public updateAccount(accountID: string, body: AccountUpdateRootReq, callback?: (error: any, data?: AccountInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfo>({
            url: "/v3/accounts/{accountID}".replace("{" + "accountID" + "}", String(accountID)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be updated.
     * @param body New API key attributes to be stored.
     */
    public updateAccountApiKey(accountID: string, apiKey: string, body: ApiKeyUpdateReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update trusted certificate.
     * An endpoint for updating existing trusted certificates.
     * @param accountID Account ID.
     * @param certId The ID of the trusted certificate to be updated.
     * @param body A trusted certificate object with attributes.
     */
    public updateAccountCertificate(accountID: string, certId: string, body: TrustedCertificateUpdateReq, callback?: (error: any, data?: TrustedCertificateInternalResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateInternalResp>({
            url: "/v3/accounts/{accountID}/trusted-certificates/{cert-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "cert-id" + "}", String(certId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update the group name.
     * An endpoint for updating a group name.
     * @param accountID Account ID.
     * @param groupID The ID of the group to be updated.
     * @param body Details of the group to be created.
     */
    public updateAccountGroupName(accountID: string, groupID: string, body: GroupUpdateInfo, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update user details.
     * An endpoint for updating user details.
     * @param accountID Account ID.
     * @param userId The ID of the user to be updated.
     * @param body A user object with attributes.
     */
    public updateAccountUser(accountID: string, userId: string, body: UserUpdateReq, callback?: (error: any, data?: UserUpdateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserUpdateResp>({
            url: "/v3/accounts/{accountID}/users/{user-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Validate the user email.
     * An endpoint for validating the user email.
     * @param accountID Account ID.
     * @param userId The ID of the user whose email is validated.
     */
    public validateAccountUserEmail(accountID: string, userId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/users/{user-id}/validate-email".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
}
/**
 * DeveloperApi
 */
export class DeveloperApi extends ApiBase {

    /**
     * Add API key to a list of groups.
     * An endpoint for adding API key to groups.   **Example usage:** &#x60;curl -X POST https://api.us-east-1.mbedcloud.com/v3/api-keys/me/groups -d &#39;[0162056a9a1586f30242590700000000,0117056a9a1586f30242590700000000]&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body A list of IDs of the groups to be updated.
     */
    public addMyApiKeyToGroups(body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/api-keys/me/groups",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new API key.
     * An endpoint for creating a new API key.   **Example usage:** &#x60;curl -X POST https://api.us-east-1.mbedcloud.com/v3/api-keys -d &#39;{\&quot;name\&quot;: \&quot;MyKey1\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body The details of the API key to be created.
     */
    public createApiKey(body: ApiKeyInfoReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Delete API key.
     * An endpoint for deleting the API key.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/api-keys/{apikey-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param apiKey The ID of the API key to be deleted.
     */
    public deleteApiKey(apiKey: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/api-keys/{apiKey}".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete a trusted certificate by ID.
     * An endpoint for deleting a trusted certificate.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/trusted-certificates/{cert-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param certId The ID of the trusted certificate to be deleted.
     */
    public deleteCertificate(certId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/trusted-certificates/{cert-id}".replace("{" + "cert-id" + "}", String(certId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all API keys
     * An endpoint for retrieving API keys in an array, optionally filtered by the owner.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/api-keys -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param keyEq API key filter.
     * @param ownerEq Owner name filter.
     */
    public getAllApiKeys(limit?: number, after?: string, order?: string, include?: string, keyEq?: string, ownerEq?: string, callback?: (error: any, data?: ApiKeyInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (keyEq !== undefined) {
            queryParameters["key__eq"] = keyEq;
        }
        if (ownerEq !== undefined) {
            queryParameters["owner__eq"] = ownerEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoRespList>({
            url: "/v3/api-keys",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all trusted certificates.
     * An endpoint for retrieving trusted certificates in an array.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/trusted-certificates -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param nameEq Filter for certificate name
     * @param serviceEq Service filter, either lwm2m or bootstrap
     * @param expireEq Expire filter in days
     * @param deviceExecutionModeEq Device execution mode, as 1 for developer certificates or as another natural integer value
     * @param deviceExecutionModeNeq Device execution mode not equals filter
     * @param ownerEq Owner name filter
     * @param enrollmentModeEq Enrollment mode filter
     * @param issuerLike Issuer filter. Finds all matches where the filter value is a case insensitive substring of the result. Example: issuer__like&#x3D;cn&#x3D;iss matches CN&#x3D;issuer.
     * @param subjectLike Subject filter. Finds all matches where the filter value is a case insensitive substring of the result. Example: subject__like&#x3D;cn&#x3D;su matches CN&#x3D;subject.
     */
    public getAllCertificates(limit?: number, after?: string, order?: string, include?: string, nameEq?: string, serviceEq?: string, expireEq?: number, deviceExecutionModeEq?: number, deviceExecutionModeNeq?: number, ownerEq?: string, enrollmentModeEq?: boolean, issuerLike?: string, subjectLike?: string, callback?: (error: any, data?: TrustedCertificateRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (nameEq !== undefined) {
            queryParameters["name__eq"] = nameEq;
        }
        if (serviceEq !== undefined) {
            queryParameters["service__eq"] = serviceEq;
        }
        if (expireEq !== undefined) {
            queryParameters["expire__eq"] = expireEq;
        }
        if (deviceExecutionModeEq !== undefined) {
            queryParameters["device_execution_mode__eq"] = deviceExecutionModeEq;
        }
        if (deviceExecutionModeNeq !== undefined) {
            queryParameters["device_execution_mode__neq"] = deviceExecutionModeNeq;
        }
        if (ownerEq !== undefined) {
            queryParameters["owner__eq"] = ownerEq;
        }
        if (enrollmentModeEq !== undefined) {
            queryParameters["enrollment_mode__eq"] = enrollmentModeEq;
        }
        if (issuerLike !== undefined) {
            queryParameters["issuer__like"] = issuerLike;
        }
        if (subjectLike !== undefined) {
            queryParameters["subject__like"] = subjectLike;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateRespList>({
            url: "/v3/trusted-certificates",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all group information.
     * An endpoint for retrieving all group information.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/policy-groups -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param nameEq Filter for group name
     */
    public getAllGroups(limit?: number, after?: string, order?: string, include?: string, nameEq?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (nameEq !== undefined) {
            queryParameters["name__eq"] = nameEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/policy-groups",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/api-keys/{apikey-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param apiKey The ID of the API key to be retrieved.
     */
    public getApiKey(apiKey: string, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys/{apiKey}".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get the API keys of a group.
     * An endpoint for listing the API keys of the group with details.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/policy-groups/{group-id}/api-keys -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param groupID The ID of the group whose API keys are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getApiKeysOfGroup(groupID: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: ApiKeyInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoRespList>({
            url: "/v3/policy-groups/{groupID}/api-keys".replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get trusted certificate by ID.
     * An endpoint for retrieving a trusted certificate by ID.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/trusted-certificates/{cert-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param certId The ID of the trusted certificate to be retrieved.
     */
    public getCertificate(certId: string, callback?: (error: any, data?: TrustedCertificateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateResp>({
            url: "/v3/trusted-certificates/{cert-id}".replace("{" + "cert-id" + "}", String(certId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get group information.
     * An endpoint for getting general information about the group.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/policy-groups/{group-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param groupID The ID of the group to be retrieved.
     */
    public getGroupSummary(groupID: string, callback?: (error: any, data?: GroupSummary, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummary>({
            url: "/v3/policy-groups/{groupID}".replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the API key.
     * An endpoint for retrieving groups of the API key.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/api-keys/me/groups -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfMyApiKey(limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/api-keys/me/groups",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get account info.
     * Returns detailed information about the account.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/accounts/me?include&#x3D;policies -H &#39;Authorization: Bearer API_KEY&#39;&#x60;.
     * @param include Comma separated additional data to return. Currently supported: limits, policies, sub_accounts.
     * @param properties Property name to be returned from account specific properties.
     */
    public getMyAccountInfo(include?: string, properties?: string, callback?: (error: any, data?: AccountInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfo>({
            url: "/v3/accounts/me",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/api-keys/me -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     */
    public getMyApiKey(callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys/me",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Remove API keys from a group.
     * An endpoint for removing API keys from groups.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/policy-groups/{group-id}/api-keys -d &#39;[0162056a9a1586f30242590700000000,0117056a9a1586f30242590700000000]&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param groupID The ID of the group whose API keys are removed.
     * @param body A list of API keys to be removed from the group.
     */
    public removeApiKeysFromGroup(groupID: string, body: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/policy-groups/{groupID}/api-keys".replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove API key from groups.
     * An endpoint for removing API key from groups.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/api-keys/me/groups -d &#39;[0162056a9a1586f30242590700000000,0117056a9a1586f30242590700000000]&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body A list of IDs of the groups to be updated.
     */
    public removeMyApiKeyFromGroups(body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/api-keys/me/groups",
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/api-keys/{apikey-id} -d &#39;{\&quot;name\&quot;: \&quot;TestApiKey25\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param apiKey The ID of the API key to be updated.
     * @param body New API key attributes to be stored.
     */
    public updateApiKey(apiKey: string, body: ApiKeyUpdateReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys/{apiKey}".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update trusted certificate.
     * An endpoint for updating existing trusted certificates.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/trusted-certificates/{cert-id} -d {\&quot;description\&quot;: \&quot;very important cert\&quot;} -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param certId The ID of the trusted certificate to be updated.
     * @param body A trusted certificate object with attributes.
     */
    public updateCertificate(certId: string, body: TrustedCertificateUpdateReq, callback?: (error: any, data?: TrustedCertificateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateResp>({
            url: "/v3/trusted-certificates/{cert-id}".replace("{" + "cert-id" + "}", String(certId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/api-keys/me -d &#39;{\&quot;name\&quot;: \&quot;TestApiKey25\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body New API key attributes to be stored.
     */
    public updateMyApiKey(body: ApiKeyUpdateReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys/me",
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
}
